<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rubina's Speed Tracker</title>
  <style>
    /* Futuristic minimal UI */
    :root{
      --bg:#06070a;
      --card:#0f1724;
      --accent:#00ffd5;
      --accent2:#8a5fff;
      --glass: rgba(255,255,255,0.04);
      font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#01040a 0%, #071025 60%);color:#e6f7ff}
    .app{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px}
    .card{width:100%;max-width:720px;padding:28px;border-radius:18px;backdrop-filter: blur(6px);background:linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 10px 30px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03)}
    h1{font-size:28px;text-align:center;margin:6px 0 22px;letter-spacing:3px;color:var(--accent)}
    .subtitle{color:#b9dff0;text-align:center;margin-bottom:18px}
    .center{display:flex;gap:18px;align-items:center;justify-content:center}
    .btn{--size:120px;width:140px;height:56px;border-radius:14px;border:none;cursor:pointer;font-weight:700;letter-spacing:1px;transition:transform .16s ease, box-shadow .16s ease;display:inline-flex;align-items:center;justify-content:center;background:linear-gradient(90deg,var(--accent),var(--accent2));color:#02101a;box-shadow:0 8px 30px rgba(0,0,0,0.6), 0 2px 8px rgba(138,95,255,0.12)}
    .btn:active{transform:translateY(2px)}
    .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#dbefff}
    .status{margin-top:20px;padding:14px;border-radius:12px;background:var(--glass);display:flex;gap:12px;align-items:center}
    .dot{width:12px;height:12px;border-radius:99px;background:#ff6b6b;box-shadow:0 0 10px rgba(255,107,107,0.18)}
    .dot.ok{background:#32d583;box-shadow:0 0 14px rgba(50,213,131,0.14)}
    .meta{font-size:14px;color:#cfeeff}
    .big{font-size:42px;font-weight:800;color:#fff;text-align:center;margin-top:18px}
    .small{font-size:13px;color:#9fc9e6;text-align:center}
    footer{margin-top:18px;font-size:12px;color:#84b7d9;text-align:center}
    @media (max-width:520px){.btn{width:120px;height:48px}}
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <h1>Rubina's Speed Tracker</h1>
      <div class="subtitle">Simple interface - Be aware of the speed limit</div>

      <div class="center">
        <button id="startBtn" class="btn">Start Tracking</button>
        <button id="stopBtn" class="btn secondary">Stop</button>
      </div>

      <div class="status" style="margin-top:18px">
        <div id="connDot" class="dot"></div>
        <div class="meta">
          <div id="statusText">Idle — not tracking</div>
          <div id="coords" style="font-size:13px;margin-top:6px;color:#9fc9e6">--</div>
        </div>
      </div>

      <div class="big" id="currentLimit">-- mph</div>
      <div class="small" id="currentRoad">Waiting for GPS...</div>

      <footer>
       Using HERE API for speed-limit and GPS lookup.
      </footer>
    </div>
  </div>

  <!-- Audio elements for the six speed files (user will place these in the same root) -->
  <audio id="a20" preload="auto" src="20.mp3"></audio>
  <audio id="a30" preload="auto" src="30.mp3"></audio>
  <audio id="a40" preload="auto" src="40.mp3"></audio>
  <audio id="a50" preload="auto" src="50.mp3"></audio>
  <audio id="a60" preload="auto" src="60.mp3"></audio>
  <audio id="a70" preload="auto" src="70.mp3"></audio>

 
 <script>
// USER CONFIG
const API_KEY = '4zCvKqaOKYJonTwhkpPVeCm8x10Q1kOrb7fV97zHAAM'; 
const ANNOUNCE_INTERVAL_MS = 20000;

// Mobile-specific settings
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
const MOBILE_SETTINGS = {
    accuracyThreshold: isMobile ? 500 : 100, // Higher tolerance for mobile
    gpsTimeout: isMobile ? 30000 : 15000, // Longer timeout for mobile
    gpsCache: isMobile ? 30000 : 10000, // Longer cache for mobile
    apiInterval: isMobile ? 8000 : 5000, // Longer API intervals for mobile
    movementThreshold: isMobile ? 80 : 50 // Require more movement on mobile
};

// UI refs
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const statusText = document.getElementById('statusText');
const coordsEl = document.getElementById('coords');
const connDot = document.getElementById('connDot');
const currentLimitEl = document.getElementById('currentLimit');
const currentRoadEl = document.getElementById('currentRoad');

// Audio map
const audioMap = {
    20: document.getElementById('a20'),
    30: document.getElementById('a30'),
    40: document.getElementById('a40'),
    50: document.getElementById('a50'),
    60: document.getElementById('a60'),
    70: document.getElementById('a70')
};

let watchId = null;
let lastZone = null;
let lastRoad = null;
let lastAddress = null;
let announceTimer = null;
let wakeLock = null;
let positionCount = 0;
let lastApiCallTime = 0;
let lastCoordinates = null;
let isTracking = false;

console.log('=== APP INITIALIZED ===');
console.log('Mobile device:', isMobile);
console.log('Mobile settings:', MOBILE_SETTINGS);

function setStatus(ok, text){
    statusText.textContent = text;
    connDot.className = 'dot ' + (ok? 'ok':'');
}

async function requestWakeLock(){
    if (!isMobile) return;
    try{
        if('wakeLock' in navigator){
            wakeLock = await navigator.wakeLock.request('screen');
            console.log('✅ Wake lock acquired for mobile');
        }
    }catch(err){
        console.warn('Wake lock request failed',err);
    }
}

function releaseWakeLock(){
    try{
        if(wakeLock){ 
            wakeLock.release(); 
            wakeLock = null;
            console.log('✅ Wake lock released');
        }
    }catch(e){}
}

function setMediaSessionMeta(limit){
    if('mediaSession' in navigator){
        navigator.mediaSession.metadata = new MediaMetadata({
            title: `Speed limit ${limit} mph`,
            artist: 'Rubina\'s Speed Tracker'
        });
    }
}

function playSpeedAudio(limit){
    const rounded = Math.round(limit/10)*10;
    const candidate = [20,30,40,50,60,70].reduce((acc,v)=> Math.abs(v-rounded) < Math.abs(acc-rounded) ? v : acc,20);
    
    const audio = audioMap[candidate];
    if(!audio) return;
    
    Object.values(audioMap).forEach(a=>{ 
        try{ a.pause(); a.currentTime = 0 } catch(e){} 
    });
    
    audio.play().catch(err=>{
        console.warn('Audio play failed:', err);
        if (isMobile) {
            setStatus(false, 'Tap screen to enable audio');
        }
    });
    setMediaSessionMeta(candidate);
}

function scheduleRepeater(limit){
    clearInterval(announceTimer);
    playSpeedAudio(limit);
    announceTimer = setInterval(()=> {
        console.log('🔊 Scheduled announcement:', limit + ' mph');
        playSpeedAudio(limit);
    }, ANNOUNCE_INTERVAL_MS);
}

function stopRepeater(){
    clearInterval(announceTimer);
    announceTimer = null;
}

// Mobile-optimized geolocation
function startGeolocation() {
    if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
    }

    const options = {
        enableHighAccuracy: true,
        maximumAge: MOBILE_SETTINGS.gpsCache,
        timeout: MOBILE_SETTINGS.gpsTimeout
    };

    console.log('📍 Starting geolocation with mobile-optimized settings:', options);
    
    watchId = navigator.geolocation.watchPosition(
        positionHandler, 
        mobileErrorHandler, 
        options
    );
}

// Enhanced mobile error handler
function mobileErrorHandler(err){
    console.warn('Geolocation error:', err);
    let errorMsg = 'GPS: ';
    
    switch(err.code) {
        case err.PERMISSION_DENIED:
            errorMsg += 'Permission denied';
            if (isMobile) {
                errorMsg += ' - Check phone settings';
            }
            break;
        case err.POSITION_UNAVAILABLE:
            errorMsg += 'Signal weak';
            if (isMobile) {
                errorMsg += ' - Move outdoors';
            }
            break;
        case err.TIMEOUT:
            errorMsg += 'Timeout';
            if (isMobile) {
                errorMsg += ' - Phone may need 1-2 minutes for GPS lock';
            }
            break;
        default:
            errorMsg += 'Check location settings';
    }
    
    setStatus(false, errorMsg);
    
    // Mobile-specific recovery suggestion
    if (isMobile && err.code === err.TIMEOUT) {
        setTimeout(() => {
            if (isTracking) {
                setStatus(false, 'Still trying... Ensure Location is enabled and set to High Accuracy');
            }
        }, 5000);
    }
}

// Calculate distance between coordinates
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371e3; // Earth radius in meters
    const φ1 = lat1 * Math.PI/180;
    const φ2 = lat2 * Math.PI/180;
    const Δφ = (lat2-lat1) * Math.PI/180;
    const Δλ = (lon2-lon1) * Math.PI/180;

    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
}

// Convert kph to mph
function kphToMph(kph) {
    return Math.round(kph * 0.621371);
}

function detectSpeedLimitFromAddress(roadName, address) {
    const roadLower = (roadName || '').toLowerCase();
    const addressLower = (address || '').toLowerCase();
    
    if (roadLower.includes('close') ||
        roadLower.includes('crescent') ||
        roadLower.includes('court') ||
        roadLower.includes('place') ||
        roadLower.includes('gardens') ||
        addressLower.includes('residential') ||
        addressLower.includes('housing') ||
        addressLower.includes('estate')) {
        return 20;
    }
    
    if (roadLower.includes('street') ||
        roadLower.includes('road') ||
        roadLower.includes('avenue') ||
        roadLower.includes('drive') ||
        roadLower.includes('lane') ||
        addressLower.includes('town') ||
        addressLower.includes('city') ||
        addressLower.includes('centre')) {
        return 30;
    }
    
    if (roadLower.includes('main road') ||
        roadLower.includes('a-road') ||
        roadLower.includes('ring road') ||
        roadLower.includes('bypass')) {
        return 40;
    }
    
    return 30;
}

// MAIN FUNCTION: Get speed limit from HERE Routing API (preserved from your working version)
async function getSpeedLimitHERE(lat, lng) {
    try {
        console.log('🛣️ Fetching speed limit from HERE Routing API...');
        
        const url = `https://router.hereapi.com/v8/routes?transportMode=car&origin=${lat},${lng}&destination=${lat},${lng}&return=travelSummary&apiKey=${API_KEY}`;
        
        const res = await fetch(url);
        const data = await res.json();
        
        console.log('HERE Routing Response:', data);
        
        let speedLimit = null;
        let roadName = null;
        
        // Extract speed limit from routing data
        if (data.routes && data.routes[0] && data.routes[0].sections) {
            const section = data.routes[0].sections[0];
            if (section.travelSummary && section.travelSummary.speedLimit) {
                speedLimit = kphToMph(section.travelSummary.speedLimit);
            }
            roadName = section.travelSummary?.streetName || null;
        }
        
        // Fallback to geocoding for address if no road from routing
        let address = null;
        if (!roadName) {
            const geoData = await getAddressHERE(lat, lng);
            roadName = geoData.road;
            address = geoData.address;
        }
        
        return { speed: speedLimit, road: roadName, address: address };
        
    } catch(e) {
        console.error('HERE Routing failed:', e);
        // Fallback to geocoding only
        return await getAddressHERE(lat, lng);
    }
}

async function getAddressHERE(lat, lng) {
    try {
        const geocodeUrl = `https://revgeocode.search.hereapi.com/v1/revgeocode?at=${lat},${lng}&apiKey=${API_KEY}`;
        const res = await fetch(geocodeUrl);
        const data = await res.json();
        
        let roadName = null;
        let address = null;
        
        if (data.items && data.items[0]) {
            const addr = data.items[0].address;
            roadName = addr.street || addr.road;
            address = addr.label || `${addr.street}, ${addr.city}`;
        }
        
        const speedLimit = detectSpeedLimitFromAddress(roadName, address);
        return { speed: speedLimit, road: roadName, address: address };
        
    } catch(e) {
        console.error('Geocoding failed:', e);
        return { speed: 30, road: null, address: null };
    }
}

// Mobile-optimized API caller with movement detection
async function lookupSpeedLimit(lat, lng) {
    const now = Date.now();
    
    // Check if we should skip API call (too soon or not moved enough)
    if (lastCoordinates) {
        const distance = calculateDistance(
            lastCoordinates.lat, lastCoordinates.lng,
            lat, lng
        );
        
        const timeSinceLastCall = now - lastApiCallTime;
        
        if (timeSinceLastCall < MOBILE_SETTINGS.apiInterval && distance < MOBILE_SETTINGS.movementThreshold) {
            console.log('⏱️ Skipping API call - recent call and minimal movement');
            return { speed: lastZone || 30, road: lastRoad, address: lastAddress };
        }
        
        console.log('📏 Movement detected:', distance.toFixed(1), 'meters');
    }
    
    lastCoordinates = { lat, lng };
    lastApiCallTime = now;
    
    return await getSpeedLimitHERE(lat, lng);
}

// Mobile-optimized position handler
async function positionHandler(pos){
    positionCount++;
    isTracking = true;
    
    const accuracy = pos.coords.accuracy;
    const lat = pos.coords.latitude;
    const lng = pos.coords.longitude;

    console.log(`📍 Position #${positionCount}:`, lat.toFixed(6), lng.toFixed(6), 'Accuracy:', accuracy, 'm');

    // Mobile-optimized accuracy handling
    let accuracyStatus = '';
    if (accuracy > MOBILE_SETTINGS.accuracyThreshold) {
        accuracyStatus = 'POOR ACCURACY';
        setStatus(false, `Weak GPS: ${Math.round(accuracy)}m - Move outdoors`);
    } else if (accuracy > 100) {
        accuracyStatus = 'AVERAGE ACCURACY';
        setStatus(true, `GPS OK: ${Math.round(accuracy)}m`);
    } else {
        accuracyStatus = 'GOOD ACCURACY';
        setStatus(true, `Good GPS: ${Math.round(accuracy)}m`);
    }

    coordsEl.textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)} — ${accuracyStatus} ${Math.round(accuracy)}m`;

    // Mobile: Process even with poor accuracy but log it
    if (accuracy > MOBILE_SETTINGS.accuracyThreshold) {
        console.log('📍 Poor mobile accuracy, but processing anyway');
    }

    // Get location data
    const lookup = await lookupSpeedLimit(lat, lng);
    
    // ALWAYS update the display
    if (lookup.address) {
        currentRoadEl.textContent = lookup.address;
    } else if (lookup.road) {
        currentRoadEl.textContent = lookup.road;
    } else {
        currentRoadEl.textContent = 'Getting location...';
    }
    
    const mph = lookup.speed || 30;
    currentLimitEl.textContent = mph + ' mph';

    // Only change audio if speed limit actually changed
    if (mph !== lastZone) {
        console.log('🚨 Speed limit changed:', lastZone, '→', mph, 'mph');
        lastZone = mph;
        scheduleRepeater(mph);
        
        const locationDesc = lookup.road || lookup.address || 'current location';
        setStatus(true, `Tracking: ${mph} mph near ${locationDesc}`);
    }

    // Always update road info for display
    lastRoad = lookup.road;
    lastAddress = lookup.address;
}

// Mobile-optimized event listeners
startBtn.addEventListener('click', async ()=>{
    console.log('🚀 Starting tracking...');
    
    // Reset state
    lastZone = null;
    lastRoad = null;
    lastAddress = null;
    positionCount = 0;
    lastApiCallTime = 0;
    lastCoordinates = null;
    isTracking = true;
    
    if(!('geolocation' in navigator)){
        setStatus(false, 'Geolocation not supported');
        return;
    }
    
    // Mobile-specific guidance
    if (isMobile) {
        setStatus(true, 'Allow location access when prompted...');
    } else {
        setStatus(true, 'Starting GPS...');
    }
    
    await requestWakeLock();
    startGeolocation();
    
    startBtn.disabled = true;
    stopBtn.disabled = false;
});

stopBtn.addEventListener('click', ()=>{
    console.log('🛑 Stopping tracking');
    isTracking = false;
    
    if(watchId !== null){ 
        navigator.geolocation.clearWatch(watchId); 
        watchId = null; 
    }
    stopRepeater();
    releaseWakeLock();
    lastZone = null;
    lastRoad = null;
    lastAddress = null;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    setStatus(false, 'Stopped');
    currentLimitEl.textContent = '-- mph';
    currentRoadEl.textContent = 'Not tracking';
    coordsEl.textContent = '--';
});

// Mobile audio warm-up (helps with autoplay restrictions)
if (isMobile) {
    document.addEventListener('click', function() {
        console.log('📱 Mobile click - warming up audio');
        Object.values(audioMap).forEach(audio => {
            audio.play().then(() => {
                audio.pause();
                console.log('✅ Audio warmed up');
            }).catch(e => console.warn('Audio warm-up failed:', e));
        });
    }, { once: true });
}

// Init state
stopBtn.disabled = true;
setStatus(false, 'Idle — tap Start Tracking');

console.log('✅ Mobile-optimized app ready');
</script>



</body>
</html>
