<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rubina's Speed Tracker</title>
  <style>
    /* Futuristic minimal UI */
    :root{
      --bg:#06070a;
      --card:#0f1724;
      --accent:#00ffd5;
      --accent2:#8a5fff;
      --glass: rgba(255,255,255,0.04);
      font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#01040a 0%, #071025 60%);color:#e6f7ff}
    .app{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px}
    .card{width:100%;max-width:720px;padding:28px;border-radius:18px;backdrop-filter: blur(6px);background:linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 10px 30px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03)}
    h1{font-size:28px;text-align:center;margin:6px 0 22px;letter-spacing:3px;color:var(--accent)}
    .subtitle{color:#b9dff0;text-align:center;margin-bottom:18px}
    .center{display:flex;gap:18px;align-items:center;justify-content:center}
    .btn{--size:120px;width:140px;height:56px;border-radius:14px;border:none;cursor:pointer;font-weight:700;letter-spacing:1px;transition:transform .16s ease, box-shadow .16s ease;display:inline-flex;align-items:center;justify-content:center;background:linear-gradient(90deg,var(--accent),var(--accent2));color:#02101a;box-shadow:0 8px 30px rgba(0,0,0,0.6), 0 2px 8px rgba(138,95,255,0.12)}
    .btn:active{transform:translateY(2px)}
    .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#dbefff}
    .status{margin-top:20px;padding:14px;border-radius:12px;background:var(--glass);display:flex;gap:12px;align-items:center}
    .dot{width:12px;height:12px;border-radius:99px;background:#ff6b6b;box-shadow:0 0 10px rgba(255,107,107,0.18)}
    .dot.ok{background:#32d583;box-shadow:0 0 14px rgba(50,213,131,0.14)}
    .meta{font-size:14px;color:#cfeeff}
    .big{font-size:42px;font-weight:800;color:#fff;text-align:center;margin-top:18px}
    .small{font-size:13px;color:#9fc9e6;text-align:center}
    footer{margin-top:18px;font-size:12px;color:#84b7d9;text-align:center}
    @media (max-width:520px){.btn{width:120px;height:48px}}
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <h1>Rubina's Speed Tracker</h1>
      <div class="subtitle">Simple interface - Be aware of the speed limit</div>

      <div class="center">
        <button id="startBtn" class="btn">Start Tracking</button>
        <button id="stopBtn" class="btn secondary">Stop</button>
      </div>

      <div class="status" style="margin-top:18px">
        <div id="connDot" class="dot"></div>
        <div class="meta">
          <div id="statusText">Idle — not tracking</div>
          <div id="coords" style="font-size:13px;margin-top:6px;color:#9fc9e6">--</div>
        </div>
      </div>

      <div class="big" id="currentLimit">-- mph</div>
      <div class="small" id="currentRoad">Waiting for GPS...</div>

      <footer>
       Using HERE API for speed-limit and GPS lookup.
      </footer>
    </div>
  </div>

  <!-- Audio elements for the six speed files (user will place these in the same root) -->
  <audio id="a20" preload="auto" src="20.mp3"></audio>
  <audio id="a30" preload="auto" src="30.mp3"></audio>
  <audio id="a40" preload="auto" src="40.mp3"></audio>
  <audio id="a50" preload="auto" src="50.mp3"></audio>
  <audio id="a60" preload="auto" src="60.mp3"></audio>
  <audio id="a70" preload="auto" src="70.mp3"></audio>

 <script>
// USER CONFIG
const API_KEY = '4zCvKqaOKYJonTwhkpPVeCm8x10Q1kOrb7fV97zHAAM'; 
const ANNOUNCE_INTERVAL_MS = 20000; // Increased to 20 seconds to reduce spam
const MIN_ACCURACY_METERS = 100;

// UI refs
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const statusText = document.getElementById('statusText');
const coordsEl = document.getElementById('coords');
const connDot = document.getElementById('connDot');
const currentLimitEl = document.getElementById('currentLimit');
const currentRoadEl = document.getElementById('currentRoad');

// Audio map
const audioMap = {
  20: document.getElementById('a20'),
  30: document.getElementById('a30'),
  40: document.getElementById('a40'),
  50: document.getElementById('a50'),
  60: document.getElementById('a60'),
  70: document.getElementById('a70')
};

let watchId = null;
let lastZone = null;
let lastRoad = null;
let lastAddress = null;
let announceTimer = null;
let wakeLock = null;
let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
let positionCount = 0;
let lastApiCallTime = 0;
const API_CALL_INTERVAL = 5000; // Only call API every 5 seconds max

console.log('=== APP INITIALIZED ===');

function setStatus(ok, text){
  statusText.textContent = text;
  connDot.className = 'dot ' + (ok? 'ok':'');
}

async function requestWakeLock(){
  if (!isMobile) return;
  try{
    if('wakeLock' in navigator){
      wakeLock = await navigator.wakeLock.request('screen');
    }
  }catch(err){}
}

function releaseWakeLock(){
  try{
    if(wakeLock){ wakeLock.release(); wakeLock = null; }
  }catch(e){}
}

function setMediaSessionMeta(limit){
  if('mediaSession' in navigator){
    navigator.mediaSession.metadata = new MediaMetadata({
      title: `Speed limit ${limit} mph`,
      artist: 'Rubina\'s Speed Tracker'
    });
  }
}

function playSpeedAudio(limit){
  const rounded = Math.round(limit/10)*10;
  const candidate = [20,30,40,50,60,70].reduce((acc,v)=> Math.abs(v-rounded) < Math.abs(acc-rounded) ? v : acc,20);
  
  const audio = audioMap[candidate];
  if(!audio) return;
  
  Object.values(audioMap).forEach(a=>{ 
    try{ a.pause(); a.currentTime = 0 } catch(e){} 
  });
  
  audio.play().catch(err=>{
    if (isMobile) {
      setStatus(false, 'Tap screen to enable audio');
    }
  });
  setMediaSessionMeta(candidate);
}

function scheduleRepeater(limit){
  clearInterval(announceTimer);
  playSpeedAudio(limit);
  announceTimer = setInterval(()=> {
    console.log('🔊 Scheduled announcement:', limit + ' mph');
    playSpeedAudio(limit);
  }, ANNOUNCE_INTERVAL_MS);
}

function stopRepeater(){
  clearInterval(announceTimer);
  announceTimer = null;
}

function startGeolocation() {
  if (watchId !== null) {
    navigator.geolocation.clearWatch(watchId);
  }

  const options = {
    enableHighAccuracy: true,
    maximumAge: 10000, // 10 second cache
    timeout: 15000
  };
  
  watchId = navigator.geolocation.watchPosition(
    positionHandler, 
    errorHandler, 
    options
  );
}

function errorHandler(err){
  let errorMsg = 'GPS: ';
  switch(err.code) {
    case err.PERMISSION_DENIED:
      errorMsg += 'Permission denied';
      break;
    case err.POSITION_UNAVAILABLE:
      errorMsg += 'Signal weak';
      break;
    case err.TIMEOUT:
      errorMsg += 'Timeout';
      break;
    default:
      errorMsg += 'Check location';
  }
  setStatus(false, errorMsg);
}

function detectSpeedLimitFromAddress(roadName, address) {
  const roadLower = (roadName || '').toLowerCase();
  const addressLower = (address || '').toLowerCase();
  
  if (roadLower.includes('close') ||
      roadLower.includes('crescent') ||
      roadLower.includes('court') ||
      roadLower.includes('place') ||
      roadLower.includes('gardens') ||
      addressLower.includes('residential') ||
      addressLower.includes('housing') ||
      addressLower.includes('estate')) {
    return 20;
  }
  
  if (roadLower.includes('street') ||
      roadLower.includes('road') ||
      roadLower.includes('avenue') ||
      roadLower.includes('drive') ||
      roadLower.includes('lane') ||
      addressLower.includes('town') ||
      addressLower.includes('city') ||
      addressLower.includes('centre')) {
    return 30;
  }
  
  if (roadLower.includes('main road') ||
      roadLower.includes('a-road') ||
      roadLower.includes('ring road') ||
      roadLower.includes('bypass')) {
    return 40;
  }
  
  return 30;
}

async function getSpeedLimitHERE(lat, lng) {
  try {
    // Use HERE Routing API which actually has speed limit data
    const url = `https://router.hereapi.com/v8/routes?transportMode=car&origin=${lat},${lng}&destination=${lat},${lng}&return=travelSummary&apiKey=${API_KEY}`;
    
    const res = await fetch(url);
    const data = await res.json();
    
    console.log('HERE Routing Response:', data);
    
    let speedLimit = null;
    let roadName = null;
    
    // Extract speed limit from routing data
    if (data.routes && data.routes[0] && data.routes[0].sections) {
      const section = data.routes[0].sections[0];
      if (section.travelSummary && section.travelSummary.speedLimit) {
        speedLimit = kphToMph(section.travelSummary.speedLimit);
      }
      roadName = section.travelSummary?.streetName || null;
    }
    
    // Fallback to geocoding for address if no road from routing
    let address = null;
    if (!roadName) {
      const geoData = await getAddressHERE(lat, lng);
      roadName = geoData.road;
      address = geoData.address;
    }
    
    return { speed: speedLimit, road: roadName, address: address };
    
  } catch(e) {
    console.error('HERE Routing failed:', e);
    // Fallback to geocoding only
    return await getAddressHERE(lat, lng);
  }
}

async function getAddressHERE(lat, lng) {
  // Your existing geocoding code for road names
  const geocodeUrl = `https://revgeocode.search.hereapi.com/v1/revgeocode?at=${lat},${lng}&apiKey=${API_KEY}`;
  const res = await fetch(geocodeUrl);
  const data = await res.json();
  
  let roadName = null;
  let address = null;
  
  if (data.items && data.items[0]) {
    const addr = data.items[0].address;
    roadName = addr.street || addr.road;
    address = addr.label || `${addr.street}, ${addr.city}`;
  }
  
  const speedLimit = detectSpeedLimitFromAddress(roadName, address);
  return { speed: speedLimit, road: roadName, address: address };
}


async function lookupSpeedLimit(lat, lng) {
  // Throttle API calls to avoid spam
  const now = Date.now();
  if (now - lastApiCallTime < API_CALL_INTERVAL) {
    console.log('⏱️ Skipping API call - too soon');
    return { speed: lastZone || 30, road: lastRoad, address: lastAddress };
  }
  
  lastApiCallTime = now;
  return await getSpeedLimitHERE(lat, lng);
}

// SIMPLE and RELIABLE position handler
async function positionHandler(pos){
  positionCount++;
  
  const accuracy = pos.coords.accuracy;
  const lat = pos.coords.latitude;
  const lng = pos.coords.longitude;

  // Update coordinates display
  let accuracyStatus = accuracy > 100 ? 'AVERAGE' : 'GOOD';
  if (accuracy > 500) accuracyStatus = 'POOR';
  
  coordsEl.textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)} — ${accuracyStatus} ACCURACY ${Math.round(accuracy)}m`;
  setStatus(true, `Tracking - ${Math.round(accuracy)}m accuracy`);

  // Only process if accuracy is reasonable
  if (accuracy > 200) {
    console.log('📍 Poor accuracy, skipping update');
    return;
  }

  // Get location data
  const lookup = await lookupSpeedLimit(lat, lng);
  
  // ALWAYS update the display
  if (lookup.address) {
    currentRoadEl.textContent = lookup.address;
  } else if (lookup.road) {
    currentRoadEl.textContent = lookup.road;
  } else {
    currentRoadEl.textContent = 'Getting location...';
  }
  
  const mph = lookup.speed || 30;
  currentLimitEl.textContent = mph + ' mph';

  // Only change audio if speed limit actually changed
  if (mph !== lastZone) {
    lastZone = mph;
    scheduleRepeater(mph);
    console.log('🚨 Speed limit changed to:', mph + ' mph');
  }

  // Always update road info for display
  lastRoad = lookup.road;
  lastAddress = lookup.address;
}

// Event listeners
startBtn.addEventListener('click', async ()=>{
  console.log('🚀 Starting tracking...');
  
  // Reset state
  lastZone = null;
  lastRoad = null;
  lastAddress = null;
  positionCount = 0;
  lastApiCallTime = 0;
  
  if(!('geolocation' in navigator)){
    setStatus(false, 'Geolocation not supported');
    return;
  }
  
  setStatus(true, 'Starting GPS...');
  await requestWakeLock();
  startGeolocation();
  
  startBtn.disabled = true;
  stopBtn.disabled = false;
});

stopBtn.addEventListener('click', ()=>{
  console.log('🛑 Stopping tracking');
  if(watchId !== null){ 
    navigator.geolocation.clearWatch(watchId); 
    watchId = null; 
  }
  stopRepeater();
  releaseWakeLock();
  lastZone = null;
  lastRoad = null;
  lastAddress = null;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  setStatus(false, 'Stopped');
  currentLimitEl.textContent = '-- mph';
  currentRoadEl.textContent = 'Not tracking';
  coordsEl.textContent = '--';
});

// Init state
stopBtn.disabled = true;
setStatus(false, 'Idle — tap Start Tracking');
</script>
</body>
</html>
