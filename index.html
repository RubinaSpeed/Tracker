<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rubina's Speed Tracker</title>
  <style>
    /* Futuristic minimal UI */
    :root{
      --bg:#06070a;
      --card:#0f1724;
      --accent:#00ffd5;
      --accent2:#8a5fff;
      --glass: rgba(255,255,255,0.04);
      font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#01040a 0%, #071025 60%);color:#e6f7ff}
    .app{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px}
    .card{width:100%;max-width:720px;padding:28px;border-radius:18px;backdrop-filter: blur(6px);background:linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 10px 30px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03)}
    h1{font-size:28px;text-align:center;margin:6px 0 22px;letter-spacing:3px;color:var(--accent)}
    .subtitle{color:#b9dff0;text-align:center;margin-bottom:18px}
    .center{display:flex;gap:18px;align-items:center;justify-content:center}
    .btn{--size:120px;width:140px;height:56px;border-radius:14px;border:none;cursor:pointer;font-weight:700;letter-spacing:1px;transition:transform .16s ease, box-shadow .16s ease;display:inline-flex;align-items:center;justify-content:center;background:linear-gradient(90deg,var(--accent),var(--accent2));color:#02101a;box-shadow:0 8px 30px rgba(0,0,0,0.6), 0 2px 8px rgba(138,95,255,0.12)}
    .btn:active{transform:translateY(2px)}
    .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#dbefff}
    .status{margin-top:20px;padding:14px;border-radius:12px;background:var(--glass);display:flex;gap:12px;align-items:center}
    .dot{width:12px;height:12px;border-radius:99px;background:#ff6b6b;box-shadow:0 0 10px rgba(255,107,107,0.18)}
    .dot.ok{background:#32d583;box-shadow:0 0 14px rgba(50,213,131,0.14)}
    .meta{font-size:14px;color:#cfeeff}
    .big{font-size:42px;font-weight:800;color:#fff;text-align:center;margin-top:18px}
    .small{font-size:13px;color:#9fc9e6;text-align:center}
    footer{margin-top:18px;font-size:12px;color:#84b7d9;text-align:center}
    @media (max-width:520px){.btn{width:120px;height:48px}}
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <h1>Rubina's Speed Tracker</h1>
      <div class="subtitle">Simple — Animated — Android-first background-friendly</div>

      <div class="center">
        <button id="startBtn" class="btn">Start Tracking</button>
        <button id="stopBtn" class="btn secondary">Stop</button>
      </div>

      <div class="status" style="margin-top:18px">
        <div id="connDot" class="dot"></div>
        <div class="meta">
          <div id="statusText">Idle — not tracking</div>
          <div id="coords" style="font-size:13px;margin-top:6px;color:#9fc9e6">--</div>
        </div>
      </div>

      <div class="big" id="currentLimit">-- mph</div>
      <div class="small" id="currentRoad">Waiting for GPS...</div>

      <footer>
        Plays 20/30/40/50/60/70 .mp3 from root. Uses HERE API for speed-limit lookup.
      </footer>
    </div>
  </div>

  <!-- Audio elements for the six speed files (user will place these in the same root) -->
  <audio id="a20" preload="auto" src="20.mp3"></audio>
  <audio id="a30" preload="auto" src="30.mp3"></audio>
  <audio id="a40" preload="auto" src="40.mp3"></audio>
  <audio id="a50" preload="auto" src="50.mp3"></audio>
  <audio id="a60" preload="auto" src="60.mp3"></audio>
  <audio id="a70" preload="auto" src="70.mp3"></audio>

  <script>
// USER CONFIG
const API_KEY = '4zCvKqaOKYJonTwhkpPVeCm8x10Q1kOrb7fV97zHAAM'; 
const ANNOUNCE_INTERVAL_MS = 15000; // 15 seconds
const MIN_ACCURACY_METERS = 50; // Only use positions with accuracy better than 50m

// UI refs
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const statusText = document.getElementById('statusText');
const coordsEl = document.getElementById('coords');
const connDot = document.getElementById('connDot');
const currentLimitEl = document.getElementById('currentLimit');
const currentRoadEl = document.getElementById('currentRoad');

// Audio map
const audioMap = {
  20: document.getElementById('a20'),
  30: document.getElementById('a30'),
  40: document.getElementById('a40'),
  50: document.getElementById('a50'),
  60: document.getElementById('a60'),
  70: document.getElementById('a70')
};

let watchId = null;
let lastZone = null;
let announceTimer = null;
let wakeLock = null;
let lastGoodPosition = null;

function setStatus(ok, text){
  statusText.textContent = text;
  connDot.className = 'dot ' + (ok? 'ok':'');
}

async function requestWakeLock(){
  try{
    if('wakeLock' in navigator){
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', ()=> console.log('Wake lock released'));
      console.log('Wake lock acquired');
    } else {
      console.log('Wake Lock API not supported in this browser');
    }
  }catch(err){
    console.warn('Wake lock request failed',err);
  }
}

function releaseWakeLock(){
  try{
    if(wakeLock){ wakeLock.release(); wakeLock = null; }
  }catch(e){/*ignore*/}
}

// MediaSession metadata for Android background behavior
function setMediaSessionMeta(limit){
  if('mediaSession' in navigator){
    navigator.mediaSession.metadata = new MediaMetadata({
      title: `Speed limit ${limit} mph`,
      artist: 'Rubina\'s Speed Tracker'
    });
  }
}

function playSpeedAudio(limit){
  const rounded = Math.round(limit/10)*10;
  const candidate = [20,30,40,50,60,70].reduce((acc,v)=> Math.abs(v-rounded) < Math.abs(acc-rounded) ? v : acc,20);
  
  const audio = audioMap[candidate];
  if(!audio) return;
  
  // Stop other audios
  Object.values(audioMap).forEach(a=>{ 
    try{ 
      a.pause(); 
      a.currentTime = 0;
    } catch(e){} 
  });
  
  audio.play().catch(err=>{
    console.warn('Playback failed:', err);
  });
  setMediaSessionMeta(candidate);
}

function scheduleRepeater(limit){
  clearInterval(announceTimer);
  playSpeedAudio(limit);
  announceTimer = setInterval(()=> playSpeedAudio(limit), ANNOUNCE_INTERVAL_MS);
}

function stopRepeater(){
  clearInterval(announceTimer);
  announceTimer = null;
}

// Smart speed limit detection based on road type and location
// Smart speed limit detection with better residential detection
function detectSpeedLimitFromAddress(roadName, address, lat, lng) {
  // Convert to lowercase for easier matching
  const roadLower = (roadName || '').toLowerCase();
  const addressLower = (address || '').toLowerCase();
  
  console.log('Detecting speed limit for:', roadLower, addressLower);
  
  // RESIDENTIAL AREAS FIRST (most restrictive)
  if (roadLower.includes('close') ||
      roadLower.includes('crescent') ||
      roadLower.includes('court') ||
      roadLower.includes('place') ||
      roadLower.includes('gardens') ||
      roadLower.includes('avenue') && !roadLower.includes('main') ||
      roadLower.includes('drive') && !roadLower.includes('main') ||
      addressLower.includes('residential') ||
      addressLower.includes('housing') ||
      addressLower.includes('estate') ||
      addressLower.includes('close') ||
      addressLower.includes('crescent') ||
      addressLower.includes('court')) {
    console.log('Detected residential area: 20 mph');
    return 20;
  }
  
  // URBAN STREETS (default 30 mph in UK)
  if (roadLower.includes('street') ||
      roadLower.includes('road') ||
      roadLower.includes('avenue') ||
      roadLower.includes('drive') ||
      roadLower.includes('lane') ||
      roadLower.includes('way') ||
      addressLower.includes('town') ||
      addressLower.includes('city') ||
      addressLower.includes('centre') ||
      addressLower.includes('urban') ||
      addressLower.includes('borough')) {
    console.log('Detected urban street: 30 mph');
    return 30;
  }
  
  // MAIN ROADS (40 mph)
  if (roadLower.includes('main road') ||
      roadLower.includes('a-road') ||
      roadLower.includes('a road') && !roadLower.includes('motorway') ||
      roadLower.includes('ring road') ||
      roadLower.includes('bypass')) {
    console.log('Detected main road: 40 mph');
    return 40;
  }
  
  // COUNTRY ROADS (60 mph)
  if (roadLower.includes('country') ||
      roadLower.includes('rural') ||
      roadLower.includes('lane') && addressLower.includes('country') ||
      addressLower.includes('country') ||
      addressLower.includes('village') && !addressLower.includes('town')) {
    console.log('Detected country road: 60 mph');
    return 60;
  }
  
  // MOTORWAYS (70 mph) - only very specific cases
  if ((roadLower.includes('motorway') || 
      roadLower.startsWith('m') || // M1, M6, etc.
      roadLower.includes('m1') ||
      roadLower.includes('m6') ||
      roadLower.includes('m25') ||
      roadLower.includes('m62')) && 
      !addressLower.includes('town') &&
      !addressLower.includes('city') &&
      !addressLower.includes('centre')) {
    console.log('Detected motorway: 70 mph');
    return 70;
  }
  
  // DUAL CARRIAGEWAYS (70 mph) - specific cases
  if (roadLower.includes('dual carriageway') &&
      !addressLower.includes('town') &&
      !addressLower.includes('city')) {
    console.log('Detected dual carriageway: 70 mph');
    return 70;
  }
  
  // DEFAULT: Assume 30 mph for safety (UK default urban speed)
  console.log('Default to urban speed: 30 mph');
  return 30;
}


// Enhanced HERE API that gets address and estimates speed limit
async function getSpeedLimitHERE(lat, lng) {
  try {
    // Use Reverse Geocoding to get address (this works with your API key)
    const geocodeUrl = `https://revgeocode.search.hereapi.com/v1/revgeocode?at=${lat},${lng}&apiKey=${API_KEY}`;
    console.log('Fetching address from:', geocodeUrl);
    
    const geocodeRes = await fetch(geocodeUrl);
    
    let speedLimit = null;
    let roadName = null;
    let address = null;
    
    if (geocodeRes.ok) {
      const geocodeData = await geocodeRes.json();
      console.log('HERE Geocode Response:', geocodeData);
      
      if (geocodeData.items && geocodeData.items[0]) {
        const location = geocodeData.items[0];
        
        // Extract address information
        if (location.address) {
          const addr = location.address;
          
          // Road name from address
          roadName = addr.street || addr.road || null;
          
          // Create a clean address display
          if (addr.street && addr.city) {
            address = `${addr.street}, ${addr.city}`;
          } else if (addr.street && addr.county) {
            address = `${addr.street}, ${addr.county}`;
          } else if (addr.label) {
            // Use the full label but shorten if too long
            address = addr.label.length > 50 ? addr.label.substring(0, 50) + '...' : addr.label;
          } else {
            address = addr.street || addr.district || addr.city || 'Unknown location';
          }
        }
        
        // Estimate speed limit based on address and road type
        speedLimit = detectSpeedLimitFromAddress(roadName, address, lat, lng);
        console.log('Estimated speed limit:', speedLimit, 'mph based on road type');
      }
    } else {
      console.warn('Geocoding failed with status:', geocodeRes.status);
    }
    
    return { 
      speed: speedLimit, 
      road: roadName,
      address: address 
    };
    
  } catch(e) {
    console.warn('HERE lookup failed', e);
    return { speed: null, road: null, address: null };
  }
}

async function lookupSpeedLimit(lat,lng){
  const result = await getSpeedLimitHERE(lat,lng);
  return result;
}

// Improved position handler with address display
async function positionHandler(pos){
  const accuracy = pos.coords.accuracy;
  const lat = pos.coords.latitude;
  const lng = pos.coords.longitude;

  // Display coordinates with accuracy warning if poor
  if (accuracy > MIN_ACCURACY_METERS) {
    coordsEl.textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)} — POOR ACCURACY ${Math.round(accuracy)}m`;
    setStatus(false, `Poor GPS: ${Math.round(accuracy)}m - move to open area`);
    
    // Still try to show address even with poor accuracy
    try {
      const lookup = await lookupSpeedLimit(lat, lng);
      if (lookup.address) {
        currentRoadEl.textContent = `Poor signal near: ${lookup.address}`;
      }
    } catch(e) {}
    
    return;
  }

  // Good accuracy position
  coordsEl.textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)} — Good accuracy ${Math.round(accuracy)}m`;
  lastGoodPosition = { lat, lng, accuracy };
  
  setStatus(true, `Tracking — Good GPS signal`);

  // Lookup speed limit AND address for this location
  const lookup = await lookupSpeedLimit(lat, lng);
  console.log('Lookup result:', lookup);
  
  // Update display with address information
  let displayText = 'Getting location data...';
  
  if (lookup.address) {
    if (lookup.road && lookup.road !== lookup.address.split(',')[0]) {
      // Show both road and address if they're different
      displayText = `${lookup.road} • ${lookup.address}`;
    } else {
      // Just show the address
      displayText = lookup.address;
    }
  } else if (lookup.road) {
    displayText = lookup.road;
  }
  
  currentRoadEl.textContent = displayText;
  
  let mph = lookup.speed;
  
  // If no speed limit detected, use fallback logic
  if (!mph) {
    mph = lastZone || 30; // Fallback to previous or default 30
  }

  currentLimitEl.textContent = mph + ' mph';

  // If new zone or first time, announce immediately
  if (mph !== lastZone) {
    lastZone = mph;
    scheduleRepeater(mph);
    const locationDesc = lookup.road || lookup.address || 'current location';
    setStatus(true, `Tracking — ${mph} mph near ${locationDesc}`);
  }
}

function errorHandler(err){
  console.warn('Geolocation error', err);
  let errorMsg = 'GPS error: ';
  
  switch(err.code) {
    case err.PERMISSION_DENIED:
      errorMsg += 'Permission denied. Please enable location access.';
      break;
    case err.POSITION_UNAVAILABLE:
      errorMsg += 'Position unavailable. Check GPS signal.';
      break;
    case err.TIMEOUT:
      errorMsg += 'GPS timeout. Try moving to open area.';
      break;
    default:
      errorMsg += err.message || 'Unknown error';
  }
  
  setStatus(false, errorMsg);
}

function startHighAccuracyGPS() {
  if (watchId !== null) {
    navigator.geolocation.clearWatch(watchId);
  }

  const options = {
    enableHighAccuracy: true,
    maximumAge: 0,        // Always fresh data
    timeout: 30000        // Wait longer for good signal
  };

  watchId = navigator.geolocation.watchPosition(
    positionHandler, 
    errorHandler, 
    options
  );
}

function checkGPSStatus() {
  if (!navigator.geolocation) {
    setStatus(false, 'Geolocation not supported');
    return;
  }
  
  navigator.geolocation.getCurrentPosition(
    (pos) => {
      const accuracy = pos.coords.accuracy;
      if (accuracy > MIN_ACCURACY_METERS) {
        setStatus(false, `Move to open area - GPS accuracy: ${Math.round(accuracy)}m`);
      } else {
        setStatus(true, 'GPS ready - good signal');
      }
    },
    (err) => {
      setStatus(false, 'GPS unavailable - check location permissions');
    },
    { enableHighAccuracy: true, timeout: 10000 }
  );
}

startBtn.addEventListener('click', async ()=>{
  if(!('geolocation' in navigator)){
    setStatus(false, 'Geolocation not supported in this browser');
    return;
  }
  
  setStatus(true, 'Acquiring GPS signal...');
  checkGPSStatus();
  
  // Try to acquire wake lock to help keep device awake on Android
  await requestWakeLock();

  // Start watching position with high accuracy settings
  startHighAccuracyGPS();
  
  startBtn.disabled = true;
  stopBtn.disabled = false;
});

stopBtn.addEventListener('click', ()=>{
  if(watchId !== null){ 
    navigator.geolocation.clearWatch(watchId); 
    watchId = null; 
  }
  stopRepeater();
  releaseWakeLock();
  lastZone = null;
  lastGoodPosition = null;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  setStatus(false, 'Stopped');
  currentLimitEl.textContent = '-- mph';
  currentRoadEl.textContent = 'Not tracking';
  coordsEl.textContent = '--';
});

// Init state
stopBtn.disabled = true;
setStatus(false, 'Idle — not tracking');

console.log('App loaded - HERE API key is working');
</script>
</body>
</html>
