<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rubina's Speed Tracker</title>
  <style>
    /* Futuristic minimal UI */
    :root{
      --bg:#06070a;
      --card:#0f1724;
      --accent:#00ffd5;
      --accent2:#8a5fff;
      --glass: rgba(255,255,255,0.04);
      font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#01040a 0%, #071025 60%);color:#e6f7ff}
    .app{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px}
    .card{width:100%;max-width:720px;padding:28px;border-radius:18px;backdrop-filter: blur(6px);background:linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 10px 30px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03)}
    h1{font-size:28px;text-align:center;margin:6px 0 22px;letter-spacing:3px;color:var(--accent)}
    .subtitle{color:#b9dff0;text-align:center;margin-bottom:18px}
    .center{display:flex;gap:18px;align-items:center;justify-content:center}
    .btn{--size:120px;width:140px;height:56px;border-radius:14px;border:none;cursor:pointer;font-weight:700;letter-spacing:1px;transition:transform .16s ease, box-shadow .16s ease;display:inline-flex;align-items:center;justify-content:center;background:linear-gradient(90deg,var(--accent),var(--accent2));color:#02101a;box-shadow:0 8px 30px rgba(0,0,0,0.6), 0 2px 8px rgba(138,95,255,0.12)}
    .btn:active{transform:translateY(2px)}
    .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#dbefff}
    .status{margin-top:20px;padding:14px;border-radius:12px;background:var(--glass);display:flex;gap:12px;align-items:center}
    .dot{width:12px;height:12px;border-radius:99px;background:#ff6b6b;box-shadow:0 0 10px rgba(255,107,107,0.18)}
    .dot.ok{background:#32d583;box-shadow:0 0 14px rgba(50,213,131,0.14)}
    .meta{font-size:14px;color:#cfeeff}
    .big{font-size:42px;font-weight:800;color:#fff;text-align:center;margin-top:18px}
    .small{font-size:13px;color:#9fc9e6;text-align:center}
    footer{margin-top:18px;font-size:12px;color:#84b7d9;text-align:center}
    @media (max-width:520px){.btn{width:120px;height:48px}}
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <h1>Rubina's Speed Tracker</h1>
      <div class="subtitle">Simple — Animated — Android-first background-friendly</div>

      <div class="center">
        <button id="startBtn" class="btn">Start Tracking</button>
        <button id="stopBtn" class="btn secondary">Stop</button>
      </div>

      <div class="status" style="margin-top:18px">
        <div id="connDot" class="dot"></div>
        <div class="meta">
          <div id="statusText">Idle — not tracking</div>
          <div id="coords" style="font-size:13px;margin-top:6px;color:#9fc9e6">--</div>
        </div>
      </div>

      <div class="big" id="currentLimit">-- mph</div>
      <div class="small" id="currentRoad">Waiting for GPS...</div>

      <footer>
        Plays 20/30/40/50/60/70 .mp3 from root. Uses HERE API for speed-limit lookup.
      </footer>
    </div>
  </div>

  <!-- Audio elements for the six speed files (user will place these in the same root) -->
  <audio id="a20" preload="auto" src="20.mp3"></audio>
  <audio id="a30" preload="auto" src="30.mp3"></audio>
  <audio id="a40" preload="auto" src="40.mp3"></audio>
  <audio id="a50" preload="auto" src="50.mp3"></audio>
  <audio id="a60" preload="auto" src="60.mp3"></audio>
  <audio id="a70" preload="auto" src="70.mp3"></audio>

  <script>
  // USER CONFIG
  const API_KEY = '4zCvKqaOKYJonTwhkpPVeCm8x10Q1kOrb7fV97zHAAM'; 
  const PROVIDER = 'HERE'; 
  const ANNOUNCE_INTERVAL_MS = 15000; // 15 seconds
  const MIN_ACCURACY_METERS = 50; // Only use positions with accuracy better than 50m

  // UI refs
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const statusText = document.getElementById('statusText');
  const coordsEl = document.getElementById('coords');
  const connDot = document.getElementById('connDot');
  const currentLimitEl = document.getElementById('currentLimit');
  const currentRoadEl = document.getElementById('currentRoad');

  // Audio map
  const audioMap = {
    20: document.getElementById('a20'),
    30: document.getElementById('a30'),
    40: document.getElementById('a40'),
    50: document.getElementById('a50'),
    60: document.getElementById('a60'),
    70: document.getElementById('a70')
  };

  let watchId = null;
  let lastZone = null;
  let announceTimer = null;
  let wakeLock = null;
  let lastGoodPosition = null;

  function setStatus(ok, text){
    statusText.textContent = text;
    connDot.className = 'dot ' + (ok? 'ok':'');
  }

  async function requestWakeLock(){
    try{
      if('wakeLock' in navigator){
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', ()=> console.log('Wake lock released'));
        console.log('Wake lock acquired');
      } else {
        console.log('Wake Lock API not supported in this browser');
      }
    }catch(err){
      console.warn('Wake lock request failed',err);
    }
  }

  function releaseWakeLock(){
    try{
      if(wakeLock){ wakeLock.release(); wakeLock = null; }
    }catch(e){/*ignore*/}
  }

  // MediaSession metadata for Android background behavior
  function setMediaSessionMeta(limit){
    if('mediaSession' in navigator){
      navigator.mediaSession.metadata = new MediaMetadata({
        title: `Speed limit ${limit} mph`,
        artist: 'Rubina\'s Speed Tracker'
      });
    }
  }

  function playSpeedAudio(limit){
    const rounded = Math.round(limit/10)*10;
    const candidate = [20,30,40,50,60,70].reduce((acc,v)=> Math.abs(v-rounded) < Math.abs(acc-rounded) ? v : acc,20);
    
    const audio = audioMap[candidate];
    if(!audio) return;
    
    // Stop other audios
    Object.values(audioMap).forEach(a=>{ 
      try{ 
        a.pause(); 
        a.currentTime = 0;
      } catch(e){} 
    });
    
    audio.play().catch(err=>{
      console.warn('Playback failed:', err);
    });
    setMediaSessionMeta(candidate);
  }

  function scheduleRepeater(limit){
    clearInterval(announceTimer);
    playSpeedAudio(limit);
    announceTimer = setInterval(()=> playSpeedAudio(limit), ANNOUNCE_INTERVAL_MS);
  }

  function stopRepeater(){
    clearInterval(announceTimer);
    announceTimer = null;
  }

  // Improved HERE API call for speed limits
  async function getSpeedLimitHERE(lat, lng) {
    try {
      // Use HERE Routing API to get link info which includes speed limits
      const url = `https://route.ls.hereapi.com/routing/7.2/getlinkinfo.json?apiKey=${API_KEY}&waypoint=${lat},${lng}`;
      
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HERE API error: ${res.status}`);
      
      const data = await res.json();
      
      console.log('HERE API Response:', data); // Debug logging
      
      let speedLimit = null;
      let roadName = null;
      
      // Parse the response for speed limit and road name
      if (data.response && data.response.link) {
        const link = data.response.link;
        
        // Extract road name
        roadName = link.roadName || link.streetName || null;
        
        // Extract speed limit (usually in KPH)
        if (link.speedLimit) {
          speedLimit = kphToMph(parseInt(link.speedLimit));
        }
        
        // Alternative speed limit locations in response
        if (!speedLimit && link.attributes && link.attributes.SPEED_LIMIT) {
          speedLimit = kphToMph(parseInt(link.attributes.SPEED_LIMIT));
        }
      }
      
      return { speed: speedLimit, road: roadName };
      
    } catch(e) {
      console.warn('HERE speed limit lookup failed', e);
      return { speed: null, road: null };
    }
  }

  // Fallback providers (kept for compatibility)
  async function getSpeedLimitGeoapify(lat,lng){
    try{
      const url = `https://api.geoapify.com/v1/routing?waypoints=${lat},${lng}&mode=drive&apiKey=${API_KEY}`;
      const res = await fetch(url);
      if(!res.ok) throw new Error('Geoapify failed');
      const j = await res.json();
      return { speed:null, road: j && j.features && j.features[0] && j.features[0].properties && j.features[0].properties.name };
    }catch(e){
      console.warn('Geoapify lookup failed',e);
      return { speed:null, road:null };
    }
  }

  async function getSpeedLimitTomTom(lat,lng){
    try{
      const url = `https://api.tomtom.com/routing/1/calculateRoute/${lat},${lng}/json?key=${API_KEY}`;
      const res = await fetch(url);
      if(!res.ok) throw new Error('TomTom failed');
      const j = await res.json();
      return { speed:null, road: j && j.routes && j.routes[0] && j.routes[0].summary && j.routes[0].summary.lengthInMeters };
    }catch(e){
      console.warn('TomTom lookup failed',e);
      return { speed:null, road:null };
    }
  }

  async function lookupSpeedLimit(lat,lng){
    if(PROVIDER === 'HERE'){
      const r = await getSpeedLimitHERE(lat,lng);
      if(r && r.speed) return r;
      const r2 = await getSpeedLimitGeoapify(lat,lng);
      return {speed: r2.speed || null, road: r.road || r2.road || null};
    }
    if(PROVIDER === 'GEOAPIFY'){
      const r = await getSpeedLimitGeoapify(lat,lng);
      if(r && r.speed) return r;
      const r2 = await getSpeedLimitHERE(lat,lng);
      return {speed: r2.speed || null, road: r.road || r2.road};
    }
    if(PROVIDER === 'TOMTOM'){
      const r = await getSpeedLimitTomTom(lat,lng);
      if(r && r.speed) return r;
      const r2 = await getSpeedLimitGeoapify(lat,lng);
      return {speed: r2.speed || null, road: r.road || r2.road};
    }
    return {speed:null, road:null};
  }

  // Convert kph to mph helper
  function kphToMph(k){ return Math.round(k * 0.621371); }

  // Improved position handler with accuracy validation
  async function positionHandler(pos){
    const accuracy = pos.coords.accuracy;
    const lat = pos.coords.latitude;
    const lng = pos.coords.longitude;

    // Display coordinates with accuracy warning if poor
    if (accuracy > MIN_ACCURACY_METERS) {
      coordsEl.textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)} — POOR ACCURACY ${Math.round(accuracy)}m`;
      setStatus(false, `Poor GPS: ${Math.round(accuracy)}m - move to open area`);
      return; // Skip processing poor accuracy positions
    }

    // Good accuracy position
    coordsEl.textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)} — Good accuracy ${Math.round(accuracy)}m`;
    lastGoodPosition = { lat, lng, accuracy };
    
    setStatus(true, `Tracking — Good GPS signal`);

    // Lookup speed limit for this location
    const lookup = await lookupSpeedLimit(lat, lng);
    
    // Always update road name if available
    if (lookup.road) {
      currentRoadEl.textContent = lookup.road;
    }
    
    let mph = lookup.speed;
    
    // If no speed limit from API, use fallback logic
    if (!mph) {
      mph = lastZone || 30; // Fallback to previous or default 30
    }

    currentLimitEl.textContent = mph + ' mph';

    // If new zone or first time, announce immediately
    if (mph !== lastZone) {
      lastZone = mph;
      scheduleRepeater(mph);
      setStatus(true, `Tracking — ${mph} mph${lookup.road ? ' on ' + lookup.road : ''}`);
    }
  }

  function errorHandler(err){
    console.warn('Geolocation error', err);
    let errorMsg = 'GPS error: ';
    
    switch(err.code) {
      case err.PERMISSION_DENIED:
        errorMsg += 'Permission denied. Please enable location access.';
        break;
      case err.POSITION_UNAVAILABLE:
        errorMsg += 'Position unavailable. Check GPS signal.';
        break;
      case err.TIMEOUT:
        errorMsg += 'GPS timeout. Try moving to open area.';
        break;
      default:
        errorMsg += err.message || 'Unknown error';
    }
    
    setStatus(false, errorMsg);
  }

  function startHighAccuracyGPS() {
    if (watchId !== null) {
      navigator.geolocation.clearWatch(watchId);
    }

    const options = {
      enableHighAccuracy: true,
      maximumAge: 0,        // Always fresh data
      timeout: 30000        // Wait longer for good signal
    };

    watchId = navigator.geolocation.watchPosition(
      positionHandler, 
      errorHandler, 
      options
    );
  }

  function checkGPSStatus() {
    if (!navigator.geolocation) {
      setStatus(false, 'Geolocation not supported');
      return;
    }
    
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const accuracy = pos.coords.accuracy;
        if (accuracy > MIN_ACCURACY_METERS) {
          setStatus(false, `Move to open area - GPS accuracy: ${Math.round(accuracy)}m`);
        } else {
          setStatus(true, 'GPS ready - good signal');
        }
      },
      (err) => {
        setStatus(false, 'GPS unavailable - check location permissions');
      },
      { enableHighAccuracy: true, timeout: 10000 }
    );
  }

  startBtn.addEventListener('click', async ()=>{
    if(!('geolocation' in navigator)){
      setStatus(false, 'Geolocation not supported in this browser');
      return;
    }
    
    setStatus(true, 'Acquiring GPS signal...');
    checkGPSStatus();
    
    // Try to acquire wake lock to help keep device awake on Android
    await requestWakeLock();

    // Start watching position with high accuracy settings
    startHighAccuracyGPS();
    
    startBtn.disabled = true;
    stopBtn.disabled = false;
  });

  stopBtn.addEventListener('click', ()=>{
    if(watchId !== null){ 
      navigator.geolocation.clearWatch(watchId); 
      watchId = null; 
    }
    stopRepeater();
    releaseWakeLock();
    lastZone = null;
    lastGoodPosition = null;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    setStatus(false, 'Stopped');
    currentLimitEl.textContent = '-- mph';
    currentRoadEl.textContent = 'Not tracking';
    coordsEl.textContent = '--';
  });

  // Init state
  stopBtn.disabled = true;
  setStatus(false, 'Idle — not tracking');

  // Add user guidance for better GPS
  console.log('For best GPS accuracy: Go outside with clear sky view and wait 30 seconds for GPS lock');
  </script>
</body>
</html>
